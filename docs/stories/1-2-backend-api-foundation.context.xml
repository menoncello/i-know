<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>2</storyId>
    <title>backend-api-foundation</title>
    <status>drafted</status>
    <generatedAt>2025-10-30T00:00:00Z</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>/Users/menoncello/repos/enterteinment/i-know/docs/stories/1-2-backend-api-foundation.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>development team</asA>
    <iWant>a scalable backend API infrastructure with authentication, database, and basic service endpoints</iWant>
    <soThat>mobile applications can securely interact with the system and store user data</soThat>
    <tasks>- [ ] Setup Elysia API framework with TypeScript configuration (AC: 1)
  - [ ] Initialize Elysia app with proper TypeScript strict mode
  - [ ] Configure API versioning (v1) with version prefix
  - [ ] Setup OpenAPI/Swagger documentation generation
  - [ ] Configure development server with hot reload
  - [ ] Establish error handling middleware structure

- [ ] Implement database layer with PostgreSQL integration (AC: 3)
  - [ ] Configure PostgreSQL connection using Bun database utilities
  - [ ] Create database migration system with schema versioning
  - [ ] Design and implement user table schema with UUID v7 primary keys
  - [ ] Create user preferences table with JSONB for flexible settings
  - [ ] Implement basic content metadata tables for actors and media
  - [ ] Setup database connection pooling and transaction management

- [ ] Build JWT authentication service (AC: 2)
  - [ ] Implement password hashing with bcrypt or similar secure method
  - [ ] Create JWT token generation and validation utilities
  - [ ] Build authentication middleware for route protection
  - [ ] Implement token refresh mechanism with secure storage
  - [ ] Create login and registration endpoints with validation
  - [ ] Setup password reset flow with secure token generation

- [ ] Implement security middleware and rate limiting (AC: 4)
  - [ ] Configure CORS policies for mobile app access
  - [ ] Implement rate limiting middleware with Redis or in-memory storage
  - [ ] Add request validation and sanitization middleware
  - [ ] Setup security headers (helmet equivalent for Elysia)
  - [ ] Implement API key authentication for system-to-system calls
  - [ ] Create audit logging for security events

- [ ] Build logging and monitoring infrastructure (AC: 5)
  - [ ] Configure structured logging with Winston or similar
  - [ ] Implement request/response logging middleware
  - [ ] Setup performance monitoring with response time tracking
  - [ ] Create error tracking and alerting system
  - [ ] Implement database query logging and performance metrics
  - [ ] Setup log aggregation and viewing capabilities

- [ ] Create health check and status endpoints (AC: 6)
  - [ ] Implement basic health check endpoint (/health)
  - [ ] Create detailed status endpoint (/status) with system metrics
  - [ ] Build database connectivity health check
  - [ ] Add external service dependency health checks
  - [ ] Implement readiness and liveness probes for containerization
  - [ ] Create system metrics endpoint for monitoring dashboards</tasks>
  </story>

  <acceptanceCriteria>1. RESTful API framework set up with proper versioning and documentation
2. User authentication service with JWT tokens and secure password handling
3. Database schema designed for users, preferences, and basic content metadata
4. API rate limiting and security middleware implemented
5. Logging and monitoring infrastructure for API performance and errors
6. Health check endpoints for system status monitoring</acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/development/api.md</path>
        <title>API Documentation</title>
        <section>API Structure and Response Format</section>
        <snippet>API responses follow consistent format with success boolean, data object, error field, and pagination metadata</snippet>
      </doc>
      <doc>
        <path>docs/development/database.md</path>
        <title>Database Schema Documentation</title>
        <section>User Schema and Connection</section>
        <snippet>Users table with UUID v7 primary keys, email uniqueness, JSONB preferences field, and timestamp management</snippet>
      </doc>
      <doc>
        <path>docs/technical-specification.md</path>
        <title>Technical Specification</title>
        <section>Data Models & Schemas</section>
        <snippet>Core entity definitions including Actor model with UUID v7, metadata fields, and User model with preferences structure</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Decision Architecture</title>
        <section>Technology Stack</section>
        <snippet>Elysia 1.4.13 with TypeScript 5.9.3 strict mode, Bun 1.3.1 runtime, PostgreSQL 18.0, UUID v7 identifiers</snippet>
      </doc>
    </docs>
    <code>
      <file>
        <path>apps/api/src/index.ts</path>
        <kind>server</kind>
        <symbol>app</symbol>
        <lines>4-17</lines>
        <reason>Existing Elysia server setup with CORS, health endpoint, and basic actors endpoint to extend</reason>
      </file>
      <file>
        <path>packages/database/src/index.ts</path>
        <kind>database</kind>
        <symbol>connectDatabase</symbol>
        <lines>18-29</lines>
        <reason>Database connection utility for PostgreSQL with configuration interface</reason>
      </file>
      <file>
        <path>apps/api/package.json</path>
        <kind>dependencies</kind>
        <symbol>dependencies</symbol>
        <lines>16-20</lines>
        <reason>Current API dependencies: elysia, @elysiajs/cors, postgres - need to add JWT and logging</reason>
      </file>
    </code>
    <dependencies>
      <ecosystem name="bun">
        <package name="elysia" version="^1.4.13"/>
        <package name="@elysiajs/cors" version="^1.2.0"/>
        <package name="postgres" version="^3.4.5"/>
        <package name="typescript" version="^5.9.3"/>
        <package name="bcrypt" version="" to-add="true"/>
        <package name="jsonwebtoken" version="" to-add="true"/>
        <package name="winston" version="" to-add="true"/>
        <package name="@types/jsonwebtoken" version="" to-add="true"/>
        <package name="@types/bcrypt" version="" to-add="true"/>
      </ecosystem>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>Use Elysia framework with TypeScript strict mode [Source: docs/architecture.md]</constraint>
    <constraint>PostgreSQL database with UUID v7 identifiers [Source: docs/architecture.md]</constraint>
    <constraint>API versioning with /api/v1/ prefix [Source: docs/development/api.md]</constraint>
    <constraint>Consistent response format with success, data, error fields [Source: docs/development/api.md]</constraint>
    <constraint>Follow kebab-case file naming, PascalCase for classes [Source: stories/1-1-project-setup-and-development-infrastructure.md]</constraint>
    <constraint>Sub-200ms API response times required [Source: docs/PRD.md#NFR002]</constraint>
    <constraint>99.5% platform uptime requirement [Source: docs/PRD.md#NFR003]</constraint>
    <constraint>Database-first architecture with PostgreSQL as central communication [Source: stories/1-1-project-setup-and-development-infrastructure.md]</constraint>
  </constraints>

  <interfaces>
    <interface name="APIResponse" kind="response-format">
      <signature>{ success: boolean; data?: T; error?: string; pagination?: { page: number; limit: number; total: number; totalPages: number; } }</signature>
      <path>docs/development/api.md</path>
    </interface>
    <interface name="DatabaseConfig" kind="config">
      <signature>{ host: string; port: number; database: string; user: string; password: string; ssl?: boolean; }</signature>
      <path>packages/database/src/index.ts</path>
    </interface>
    <interface name="User" kind="database-entity">
      <signature>{ id: string; email: string; preferences: UserPreferences; subscription: UserSubscription; createdAt: string; updatedAt: string; }</signature>
      <path>docs/technical-specification.md</path>
    </interface>
    <interface name="Actor" kind="database-entity">
      <signature>{ id: string; name: string; bio?: string; birthDate?: string; photoUrl?: string; imdbId?: string; knownFor: string[]; filmography: FilmographyEntry[]; metadata: ActorMetadata; createdAt: string; updatedAt: string; }</signature>
      <path>docs/technical-specification.md</path>
    </interface>
  </interfaces>

  <tests>
    <standards>Use Bun test framework with co-located test files in __tests__ directories. Follow patterns established in Story 1.1 for API testing, database testing with separate test database, and integration testing.</standards>
    <locations>apps/api/src/**/*.test.ts, packages/database/src/**/*.test.ts, tests/integration/**/*.test.ts</locations>
    <ideas>
      <test idea="Test health endpoint returns correct status and timestamp" ac-id="6"/>
      <test idea="Test database connection and user table creation" ac-id="3"/>
      <test idea="Test JWT token generation and validation flow" ac-id="2"/>
      <test idea="Test API rate limiting middleware functionality" ac-id="4"/>
      <test idea="Test logging middleware captures request/response data" ac-id="5"/>
      <test idea="Test CORS configuration allows mobile app origins" ac-id="4"/>
      <test idea="Test API versioning with /api/v1/ prefix" ac-id="1"/>
    </ideas>
  </tests>
</story-context>