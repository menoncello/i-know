# I Know - Technical Specification

**Author:** Eduardo Menoncello
**Date:** 2025-10-29
**Project Level:** Level 3 Greenfield Software
**Project Type:** Entertainment Intelligence Platform
**Development Context:** New product development with modern TypeScript stack

---

## Source Tree Structure

### Monorepo Organization

```
i-know/
├── apps/
│   ├── web/                           # Astro + React frontend application
│   │   ├── src/
│   │   │   ├── components/
│   │   │   │   ├── ui/                # shadcn/ui components
│   │   │   │   │   ├── actor-card.tsx
│   │   │   │   │   ├── content-banner.tsx
│   │   │   │   │   ├── discovery-grid.tsx
│   │   │   │   │   └── viewing-history.tsx
│   │   │   │   ├── layout/
│   │   │   │   │   ├── header.astro
│   │   │   │   │   ├── footer.astro
│   │   │   │   │   └── mobile-nav.astro
│   │   │   │   └── features/
│   │   │   │       ├── actor-search/
│   │   │   │       ├── discovery/
│   │   │   │       └── preferences/
│   │   │   ├── pages/
│   │   │   │   ├── index.astro         # Home/Discovery
│   │   │   │   ├── search.astro       # Actor search
│   │   │   │   ├── actor/[id].astro   # Actor profile
│   │   │   │   └── profile.astro      # User profile
│   │   │   ├── layouts/
│   │   │   │   ├── base.astro
│   │   │   │   └── mobile.astro
│   │   │   ├── services/
│   │   │   │   ├── api-client.ts
│   │   │   │   ├── storage-service.ts
│   │   │   │   └── search-service.ts
│   │   │   ├── types/
│   │   │   │   └── actor-types.ts
│   │   │   ├── utils/
│   │   │   │   ├── format-utils.ts
│   │   │   │   └── validation.ts
│   │   │   ├── styles/
│   │   │   │   └── globals.css
│   │   │   └── env.d.ts
│   │   ├── tests/
│   │   │   ├── components/
│   │   │   ├── pages/
│   │   │   └── services/
│   │   ├── public/
│   │   ├── astro.config.mjs
│   │   ├── tailwind.config.mjs
│   │   ├── tsconfig.json
│   │   ├── package.json
│   │   └── bun.lockb
│   ├── api/                           # Elysia backend API service
│   │   ├── src/
│   │   │   ├── routes/
│   │   │   │   ├── actors/
│   │   │   │   │   ├── index.ts       # GET /api/v1/actors
│   │   │   │   │   ├── [id].ts        # GET /api/v1/actors/:id
│   │   │   │   │   └── search.ts      # GET /api/v1/actors/search
│   │   │   │   ├── users/
│   │   │   │   │   ├── index.ts       # POST /api/v1/users
│   │   │   │   │   ├── login.ts       # POST /api/v1/users/login
│   │   │   │   │   └── preferences.ts # PUT /api/v1/users/preferences
│   │   │   │   └── health.ts          # GET /api/v1/health
│   │   │   ├── models/
│   │   │   │   ├── actor-model.ts
│   │   │   │   ├── user-model.ts
│   │   │   │   └── viewing-history-model.ts
│   │   │   ├── services/
│   │   │   │   ├── database-service.ts
│   │   │   │   ├── actor-service.ts
│   │   │   │   └── user-service.ts
│   │   │   ├── middleware/
│   │   │   │   ├── cors-middleware.ts
│   │   │   │   ├── error-middleware.ts
│   │   │   │   └── logging-middleware.ts
│   │   │   ├── database/
│   │   │   │   ├── migrations/
│   │   │   │   ├── seeds/
│   │   │   │   └── connection.ts
│   │   │   ├── types/
│   │   │   │   ├── api-types.ts
│   │   │   │   └── database-types.ts
│   │   │   └── utils/
│   │   │       ├── validation.ts
│   │   │       └── error-handling.ts
│   │   ├── tests/
│   │   │   ├── routes/
│   │   │   ├── services/
│   │   │   └── models/
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   └── bun.lockb
│   └── scraper/                       # Bun scraping service
│       ├── src/
│       │   ├── services/
│       │   │   ├── imdb-service.ts     # Revolutionary GET method
│       │   │   ├── puppeteer-service.ts # Fallback scraper
│       │   │   └── data-processor.ts   # Transform and store
│       │   ├── models/
│       │   │   ├── actor-scraped-model.ts
│       │   │   └── content-model.ts
│       │   ├── database/
│       │   │   └── connection.ts       # Shared DB connection
│       │   ├── utils/
│       │   │   ├── rate-limiter.ts
│       │   │   └── retry-logic.ts
│       │   ├── types/
│       │   │   └── scraper-types.ts
│       │   └── scheduler/
│       │       └── cron-jobs.ts        # Daily updates
│       ├── tests/
│       │   ├── services/
│       │   └── integration/
│       ├── package.json
│       ├── tsconfig.json
│       └── bun.lockb
├── packages/
│   ├── ui/                            # Shared shadcn/ui components
│   │   ├── src/
│   │   │   ├── components/
│   │   │   │   ├── actor-card/
│   │   │   │   │   ├── actor-card.tsx
│   │   │   │   │   └── actor-card.stories.tsx
│   │   │   │   ├── content-banner/
│   │   │   │   ├── discovery-grid/
│   │   │   │   └── viewing-history/
│   │   │   ├── utils/
│   │   │   │   └── cn.ts
│   │   │   └── index.ts
│   │   ├── package.json
│   │   └── tsconfig.json
│   ├── types/                         # Shared TypeScript types
│   │   ├── src/
│   │   │   ├── actor-types.ts
│   │   │   ├── user-types.ts
│   │   │   ├── api-types.ts
│   │   │   └── database-types.ts
│   │   ├── package.json
│   │   └── tsconfig.json
│   ├── database/                      # Shared database utilities
│   │   ├── src/
│   │   │   ├── connection.ts
│   │   │   ├── migrations/
│   │   │   ├── seeds/
│   │   │   └── schemas/
│   │   │       ├── actor-schema.sql
│   │   │       ├── user-schema.sql
│   │   │       └── viewing-history-schema.sql
│   │   ├── package.json
│   │   └── tsconfig.json
│   └── utils/                         # Shared utilities
│       ├── src/
│       │   ├── logger.ts
│       │   ├── crypto.ts
│       │   ├── date-utils.ts
│       │   └── validation.ts
│       ├── package.json
│       └── tsconfig.json
├── tests/                             # E2E and integration tests
│   ├── e2e/
│   ├── integration/
│   └── performance/
├── docs/                              # Documentation
│   ├── api/
│   ├── deployment/
│   └── user-guides/
├── scripts/                           # Build and deployment scripts
│   ├── build.sh
│   ├── deploy.sh
│   └── database-migrate.sh
├── .github/
│   └── workflows/
│       ├── ci.yml
│       └── deploy.yml
├── package.json                       # Root package.json
├── turbo.json                         # Turborepo configuration
├── pnpm-workspace.yaml               # PNPM workspace config
├── tsconfig.json                      # Root TypeScript config
├── .gitignore
├── .env.example
├── README.md
└── bun.lockb
```

### File Organization Patterns

**Naming Conventions:**

- **Files**: kebab-case with technology suffix (`actor-card.tsx`, `api-types.ts`)
- **Directories**: kebab-case for features, camelCase for utilities
- **Components**: PascalCase with descriptive names (`ActorCard`, `ContentBanner`)
- **Database Tables**: snake_case plural (`actors`, `users`, `viewing_history`)
- **API Routes**: kebab-case with versioning (`/api/v1/actor-profiles`)

**Import Order:**

1. External libraries (React, Elysia, etc.)
2. Internal packages (@iknow/ui, @iknow/types)
3. Relative imports (./components, ../services)
4. Type-only imports last

---

## Technical Approach

### Core Architectural Principles

**1. Database-First Service Communication**
All services communicate through a centralized PostgreSQL database rather than direct API calls or message brokers. This eliminates service coupling and provides natural data consistency.

**2. Service-Oriented Architecture**
Independent frontend, backend API, and scraper services with clear separation of concerns and autonomous deployment capabilities.

**3. Performance-First Design**
Sub-500ms response times for actor identification through optimized database queries, intelligent caching, and modern runtime performance.

**4. Type Safety Throughout**
Strict TypeScript configuration with no `any` types, end-to-end type safety from database to frontend components.

### Key Technical Decisions

**Monorepo Management with Turborepo 2.5.9**

- Intelligent build caching and dependency optimization
- Parallel build execution for independent applications
- Shared dependency hoisting for reduced bundle sizes
- Unified development and deployment pipeline

**Modern TypeScript Stack**

- Bun 1.3.1 runtime for ultra-fast performance
- Elysia 1.4.13 for type-safe backend development
- Astro 5.12.0 for performance-optimized frontend
- React 19.2.0 with React Compiler support

**Data Strategy**

- PostgreSQL 18.0 with advanced indexing and performance features
- UUID v7 for time-ordered, globally unique identifiers
- Multi-tier IMDB data acquisition (API → Scraping → Cache)
- Database-first communication pattern

### Performance Targets

**Response Time Requirements:**

- Actor identification: < 500ms (95th percentile)
- Search queries: < 300ms (95th percentile)
- User authentication: < 200ms (95th percentile)
- Content loading: < 1s initial, < 300ms subsequent

**Scalability Targets:**

- 1M+ concurrent users
- 10K+ requests per second
- 99.5% uptime availability
- Sub-second database queries with proper indexing

---

## Implementation Stack

### Core Technologies

| Technology          | Version             | Purpose               | Key Features                           |
| ------------------- | ------------------- | --------------------- | -------------------------------------- |
| **Runtime**         | Bun 1.3.1           | JavaScript runtime    | Ultra-fast performance, built-in tools |
| **Frontend**        | Astro 5.12.0        | Web framework         | Islands architecture, SSR/SSG          |
| **UI Framework**    | React 19.2.0        | Component framework   | React Compiler, concurrent features    |
| **Backend**         | Elysia 1.4.13       | API framework         | Type-safe, excellent TypeScript        |
| **Database**        | PostgreSQL 18.0     | Data storage          | Advanced indexing, JSONB support       |
| **Styling**         | Tailwind CSS 4.1.16 | CSS framework         | Utility-first, modern v4 features      |
| **Components**      | shadcn/ui 3.5.0     | Component library     | Modern, accessible, customizable       |
| **Monorepo**        | Turborepo 2.5.9     | Build system          | Optimized builds, caching              |
| **Package Manager** | PNPM 9.14.4         | Dependency management | Fast, disk-space efficient             |

### Development Tools

| Tool           | Purpose         | Configuration                 |
| -------------- | --------------- | ----------------------------- |
| **TypeScript** | Type safety     | Strict mode, no any types     |
| **ESLint**     | Code quality    | Custom rules for consistency  |
| **Prettier**   | Code formatting | Consistent style across team  |
| **Prisma**     | Database ORM    | Type-safe database operations |
| **Vitest**     | Unit testing    | Fast test runner              |
| **Playwright** | E2E testing     | Cross-browser testing         |

### Infrastructure Stack

| Service                 | Purpose                    | Provider                          |
| ----------------------- | -------------------------- | --------------------------------- |
| **Application Hosting** | Web application deployment | Railway (initial), AWS (scale)    |
| **Database**            | PostgreSQL hosting         | Railway/Render (initial), AWS RDS |
| **CDN**                 | Static asset delivery      | CloudFlare                        |
| **Monitoring**          | Application performance    | DataDog/New Relic                 |
| **Logging**             | Structured logging         | ELK Stack                         |
| **CI/CD**               | Build and deployment       | GitHub Actions                    |

---

## Technical Details

### Database Schema Design

**Core Entities:**

```sql
-- Actors table with search optimization
CREATE TABLE actors (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v7(),
  name VARCHAR(255) NOT NULL,
  bio TEXT,
  birth_date DATE,
  photo_url TEXT,
  imdb_id VARCHAR(50) UNIQUE,
  metadata JSONB DEFAULT '{}', -- Flexible additional data
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Content table (movies, series, episodes)
CREATE TABLE content (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v7(),
  title VARCHAR(500) NOT NULL,
  type content_type NOT NULL CHECK (type IN ('movie', 'series', 'episode')),
  release_year INTEGER,
  imdb_id VARCHAR(50) UNIQUE,
  poster_url TEXT,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Filmography relationships
CREATE TABLE filmography (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v7(),
  actor_id UUID REFERENCES actors(id) ON DELETE CASCADE,
  content_id UUID REFERENCES content(id) ON DELETE CASCADE,
  role_name VARCHAR(255),
  is_main_role BOOLEAN DEFAULT FALSE,
  year INTEGER,
  episode_number INTEGER,
  season_number INTEGER,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(actor_id, content_id, role_name, COALESCE(season_number, 0), COALESCE(episode_number, 0))
);

-- Users table with preferences
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v7(),
  email VARCHAR(255) UNIQUE NOT NULL,
  username VARCHAR(100) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  preferences JSONB DEFAULT '{"notifications": true, "theme": "light", "language": "en"}',
  subscription_tier subscription_tier DEFAULT 'free',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Viewing history with rich context
CREATE TABLE viewing_history (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v7(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  actor_id UUID REFERENCES actors(id) ON DELETE CASCADE,
  content_id UUID REFERENCES content(id) ON DELETE CASCADE,
  viewed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  context JSONB DEFAULT '{}', -- Platform, duration, device, etc.
  UNIQUE(user_id, actor_id, content_id, DATE(viewed_at))
);

-- Watchlist management
CREATE TABLE watchlist (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v7(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  content_id UUID REFERENCES content(id) ON DELETE CASCADE,
  added_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  status watchlist_status DEFAULT 'to_watch',
  notes TEXT,
  UNIQUE(user_id, content_id)
);
```

**Performance Indexes:**

```sql
-- Full-text search indexes
CREATE INDEX CONCURRENTLY idx_actors_search_vector
ON actors USING gin(to_tsvector('english', name || ' ' || COALESCE(bio, '')));

CREATE INDEX CONCURRENTLY idx_content_search_vector
ON content USING gin(to_tsvector('english', title));

-- Relationship and query optimization
CREATE INDEX CONCURRENTLY idx_filmography_actor ON filmography(actor_id);
CREATE INDEX CONCURRENTLY idx_filmography_content ON filmography(content_id);
CREATE INDEX CONCURRENTLY idx_filmography_composite ON filmography(actor_id, content_id, is_main_role);

-- Time-based queries
CREATE INDEX CONCURRENTLY idx_viewing_history_user_time
ON viewing_history(user_id, viewed_at DESC);

CREATE INDEX CONCURRENTLY idx_watchlist_user_time
ON watchlist(user_id, added_at DESC);

-- JSONB optimization
CREATE INDEX CONCURRENTLY idx_actors_metadata_gin
ON actors USING gin(metadata);

CREATE INDEX CONCURRENTLY idx_users_preferences_gin
ON users USING gin(preferences);
```

### API Design

**RESTful API Structure:**

```typescript
// API Response Envelope
interface ApiResponse<T> {
  data: T;
  error?: ApiError;
  meta?: {
    pagination?: PaginationMeta;
    searchTime?: number;
    total?: number;
  };
}

// Pagination Meta
interface PaginationMeta {
  total: number;
  limit: number;
  offset: number;
  hasMore: boolean;
}

// Error Response
interface ApiError {
  code: string;
  message: string;
  details?: Record<string, any>;
  timestamp: string;
}
```

**Core API Endpoints:**

```typescript
// Actor endpoints
GET /api/v1/actors/:id                    // Get actor by ID
GET /api/v1/actors/search                 // Search actors
GET /api/v1/actors/:id/filmography        // Get actor filmography
GET /api/v1/actors/trending               // Get trending actors

// Content endpoints
GET /api/v1/content/:id                   // Get content by ID
GET /api/v1/content/search                // Search content
GET /api/v1/content/:id/cast              // Get content cast

// User endpoints
POST /api/v1/users                        // Create user
POST /api/v1/users/login                  // User login
GET /api/v1/users/:id                     // Get user profile
PUT /api/v1/users/:id/preferences         // Update preferences
GET /api/v1/users/:id/viewing-history     // Get viewing history
GET /api/v1/users/:id/watchlist           // Get watchlist
POST /api/v1/users/:id/watchlist          // Add to watchlist
DELETE /api/v1/users/:id/watchlist/:id    // Remove from watchlist

// Health and system
GET /api/v1/health                        // Health check
GET /api/v1/metrics                       // System metrics
```

**Request/Response Examples:**

```typescript
// GET /api/v1/actors/search?q=tom hanks&limit=20
interface ActorSearchRequest {
  q: string; // Search query (required)
  limit?: number; // Results per page (default: 20, max: 100)
  offset?: number; // Pagination offset (default: 0)
  type?: 'movie' | 'series' | 'all'; // Content type filter
  year?: number; // Filter by year
}

interface ActorSearchResponse {
  data: Array<{
    id: string;
    name: string;
    photoUrl?: string;
    knownFor: string[];
    matchScore: number;
  }>;
  meta: {
    pagination: PaginationMeta;
    searchTime: number;
  };
}
```

### Data Models

**Core TypeScript Interfaces:**

```typescript
// Actor model
export interface Actor {
  id: string; // UUID v7
  name: string;
  bio?: string;
  birthDate?: string; // ISO date
  photoUrl?: string;
  imdbId?: string;
  knownFor: string[]; // Array of content titles
  filmography: FilmographyEntry[];
  metadata: Record<string, any>; // Flexible additional data
  createdAt: string; // ISO timestamp
  updatedAt: string;
}

// Filmography entry
export interface FilmographyEntry {
  id: string;
  contentId: string;
  title: string;
  type: 'movie' | 'series' | 'episode';
  year?: number;
  roleName: string;
  isMainRole: boolean;
  seasonNumber?: number;
  episodeNumber?: number;
}

// User model
export interface User {
  id: string; // UUID v7
  email: string;
  username: string;
  preferences: UserPreferences;
  subscriptionTier: 'free' | 'premium' | 'pro';
  viewingHistory: ViewingHistoryEntry[];
  watchlist: WatchlistEntry[];
  createdAt: string;
  updatedAt: string;
}

// User preferences
export interface UserPreferences {
  notifications: boolean;
  theme: 'light' | 'dark' | 'auto';
  language: string;
  autoplay: boolean;
  showSpoilers: boolean;
  defaultContentQuality: 'auto' | 'sd' | 'hd' | 'uhd';
}

// Viewing history
export interface ViewingHistoryEntry {
  id: string;
  actor: ActorSummary;
  content: ContentSummary;
  viewedAt: string;
  context: {
    platform?: string;
    duration?: number;
    device?: string;
    location?: string;
  };
}

// Content summary
export interface ContentSummary {
  id: string;
  title: string;
  type: 'movie' | 'series' | 'episode';
  year?: number;
  posterUrl?: string;
}
```

### Service Architecture

**Actor Service Implementation:**

```typescript
// apps/api/src/services/actor-service.ts
export class ActorService {
  constructor(private db: DatabaseService) {}

  async getActor(id: string): Promise<Actor> {
    const actor = await this.db.queryOne<Actor>(
      `
      SELECT a.*,
             array_agg(DISTINCT c.title) as known_for
      FROM actors a
      LEFT JOIN filmography f ON a.id = f.actor_id
      LEFT JOIN content c ON f.content_id = c.id
      WHERE a.id = $1
      GROUP BY a.id
    `,
      [id],
    );

    if (!actor) {
      throw new ApiError('ACTOR_NOT_FOUND', 'Actor not found', { actorId: id }, 404);
    }

    return actor;
  }

  async searchActors(query: ActorSearchRequest): Promise<ActorSearchResponse> {
    const startTime = Date.now();
    const { q, limit = 20, offset = 0, type, year } = query;

    // Build search query with full-text search
    let sql = `
      SELECT DISTINCT a.id, a.name, a.photo_url,
             array_agg(DISTINCT c.title) FILTER (WHERE c.title IS NOT NULL) as known_for,
             ts_rank(search_vector, plainto_tsquery('english', $1)) as match_score
      FROM actors a
      LEFT JOIN filmography f ON a.id = f.actor_id
      LEFT JOIN content c ON f.content_id = c.id
      WHERE a.search_vector @@ plainto_tsquery('english', $1)
    `;

    const params: any[] = [q];
    let paramIndex = 2;

    // Add filters
    if (type && type !== 'all') {
      sql += ` AND c.type = $${paramIndex}`;
      params.push(type);
      paramIndex++;
    }

    if (year) {
      sql += ` AND c.release_year = $${paramIndex}`;
      params.push(year);
      paramIndex++;
    }

    sql += `
      GROUP BY a.id, a.name, a.photo_url, a.search_vector
      ORDER BY match_score DESC, a.name ASC
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `;

    params.push(limit, offset);

    const actors = await this.db.query<any>(sql, params);
    const searchTime = Date.now() - startTime;

    return {
      data: actors.map(actor => ({
        id: actor.id,
        name: actor.name,
        photoUrl: actor.photo_url,
        knownFor: actor.known_for || [],
        matchScore: parseFloat(actor.match_score),
      })),
      meta: {
        searchTime,
        // Add pagination count query if needed
      },
    };
  }
}
```

### Authentication & Security

**JWT Token Implementation:**

```typescript
// apps/api/src/services/auth-service.ts
export class AuthService {
  constructor(private db: DatabaseService) {}

  async login(email: string, password: string): Promise<AuthResponse> {
    const user = await this.db.queryOne<User>(
      `
      SELECT id, email, username, password_hash, preferences, subscription_tier
      FROM users
      WHERE email = $1
    `,
      [email],
    );

    if (!user) {
      throw new ApiError('INVALID_CREDENTIALS', 'Invalid email or password', {}, 401);
    }

    const isValidPassword = await argon2.verify(user.passwordHash, password);
    if (!isValidPassword) {
      throw new ApiError('INVALID_CREDENTIALS', 'Invalid email or password', {}, 401);
    }

    const tokens = await this.generateTokens(user);

    return {
      user: {
        id: user.id,
        email: user.email,
        username: user.username,
        preferences: user.preferences,
        subscriptionTier: user.subscription_tier,
      },
      tokens,
    };
  }

  private async generateTokens(user: User): Promise<AuthTokens> {
    const accessToken = await jwt.sign(
      {
        userId: user.id,
        email: user.email,
        subscriptionTier: user.subscription_tier,
      },
      process.env.JWT_SECRET!,
      { expiresIn: '15m' },
    );

    const refreshToken = await jwt.sign(
      { userId: user.id, type: 'refresh' },
      process.env.JWT_REFRESH_SECRET!,
      { expiresIn: '7d' },
    );

    // Store refresh token in database for device tracking
    await this.db.query(
      `
      INSERT INTO refresh_tokens (user_id, token_hash, device_info, expires_at)
      VALUES ($1, $2, $3, $4)
    `,
      [
        user.id,
        await argon2.hash(refreshToken),
        { device: 'web', ip: '127.0.0.1' }, // Extract from request
        new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
      ],
    );

    return { accessToken, refreshToken };
  }
}
```

**Middleware Implementation:**

```typescript
// apps/api/src/middleware/auth-middleware.ts
export const authMiddleware = (app: Elysia) =>
  app.derive(async ({ request, set }) => {
    const authHeader = request.headers.get('authorization');

    if (!authHeader?.startsWith('Bearer ')) {
      set.status = 401;
      throw new ApiError('MISSING_TOKEN', 'Authentication required');
    }

    const token = authHeader.replace('Bearer ', '');

    try {
      const payload = (await jwt.verify(token, process.env.JWT_SECRET!)) as any;
      const user = await app.db.queryOne<User>(
        'SELECT id, email, username, subscription_tier FROM users WHERE id = $1',
        [payload.userId],
      );

      if (!user) {
        throw new ApiError('USER_NOT_FOUND', 'User not found');
      }

      return { user };
    } catch (error) {
      set.status = 401;
      throw new ApiError('INVALID_TOKEN', 'Invalid or expired token');
    }
  });
```

### Performance Optimization

**Caching Strategy:**

```typescript
// apps/api/src/services/cache-service.ts
export class CacheService {
  constructor(private redis: Redis) {}

  // Cache actor profiles for 24 hours
  async getCachedActor(id: string): Promise<Actor | null> {
    const cached = await this.redis.get(`actor:${id}`);
    return cached ? JSON.parse(cached) : null;
  }

  async setCachedActor(id: string, actor: Actor): Promise<void> {
    await this.redis.setex(
      `actor:${id}`,
      24 * 60 * 60, // 24 hours
      JSON.stringify(actor),
    );
  }

  // Cache search results for 5 minutes
  async getCachedSearch(query: string): Promise<ActorSearchResponse | null> {
    const key = `search:${Buffer.from(query).toString('base64')}`;
    const cached = await this.redis.get(key);
    return cached ? JSON.parse(cached) : null;
  }

  async setCachedSearch(query: string, results: ActorSearchResponse): Promise<void> {
    const key = `search:${Buffer.from(query).toString('base64')}`;
    await this.redis.setex(key, 5 * 60, JSON.stringify(results)); // 5 minutes
  }
}
```

**Database Connection Pooling:**

```typescript
// packages/database/src/connection.ts
export class DatabaseService {
  private pool: Pool;

  constructor(connectionString: string) {
    this.pool = new Pool({
      connectionString,
      max: 20, // Maximum connections
      min: 5, // Minimum connections
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000,
    });
  }

  async query<T>(sql: string, params: any[] = []): Promise<T[]> {
    const client = await this.pool.connect();
    try {
      const result = await client.query(sql, params);
      return result.rows;
    } finally {
      client.release();
    }
  }

  async queryOne<T>(sql: string, params: any[] = []): Promise<T | null> {
    const rows = await this.query<T>(sql, params);
    return rows[0] || null;
  }
}
```

---

## Development Setup

### Prerequisites

**Required Tools:**

- **Bun 1.3.1+**: JavaScript runtime and package manager
- **Node.js 20+**: Required for some Astro dependencies
- **PostgreSQL 18+**: Local database development
- **Git**: Version control
- **VS Code**: Recommended IDE with extensions

**VS Code Extensions (recommended):**

```json
{
  "recommendations": [
    "astro-build.astro-vscode",
    "bradlc.vscode-tailwindcss",
    "dbaeumer.vscode-eslint",
    "esbenp.prettier-vscode",
    "ms-vscode.vscode-typescript-next",
    "prisma.prisma",
    "ms-vscode.vscode-json"
  ]
}
```

### Installation Commands

```bash
# 1. Clone the repository
git clone <repository-url>
cd i-know

# 2. Install Bun (if not already installed)
curl -fsSL https://bun.sh/install | bash

# 3. Install all dependencies
bun install

# 4. Setup environment variables
cp .env.example .env.local
# Edit .env.local with your configuration

# 5. Setup PostgreSQL database
# Create database: createdb iknow_dev
# Update DATABASE_URL in .env.local

# 6. Run database migrations
bun run db:migrate

# 7. Seed database with initial data
bun run db:seed

# 8. Start development servers
bun run dev          # Starts all apps (web:4321, api:3000, scraper:3001)
```

### Environment Configuration

**.env.local Example:**

```bash
# Database
DATABASE_URL="postgresql://username:password@localhost:5432/iknow_dev"
REDIS_URL="redis://localhost:6379"

# Authentication
JWT_SECRET="your-super-secret-jwt-key-min-32-chars"
JWT_REFRESH_SECRET="your-refresh-secret-key-min-32-chars"

# CORS
CORS_ORIGINS="http://localhost:4321,https://iknow.app"

# Rate Limiting
RATE_LIMIT_REQUESTS="100"
RATE_LIMIT_WINDOW="900000" # 15 minutes in ms

# IMDB Services
IMDB_API_KEY="your-imdb-api-key"
IMDB_RATE_LIMIT="2000" # 2 seconds between requests

# Feature Flags
ENABLE_SCRAPING="true"
ENABLE_CACHE="true"
ENABLE_ANALYTICS="false"

# Development
NODE_ENV="development"
LOG_LEVEL="debug"
```

### Development Scripts

**Available Commands:**

```bash
# Development
bun run dev              # Start all services in development mode
bun run dev:web          # Frontend only (http://localhost:4321)
bun run dev:api          # Backend only (http://localhost:3000)
bun run dev:scraper      # Scraper only (http://localhost:3001)

# Building
bun run build            # Build all applications
bun run build:web        # Frontend only
bun run build:api        # Backend only
bun run build:scraper    # Scraper only

# Testing
bun run test             # Run all tests
bun run test:unit        # Unit tests only
bun run test:integration # Integration tests only
bun run test:e2e         # End-to-end tests only
bun run test:coverage    # Test with coverage report

# Database
bun run db:migrate       # Run database migrations
bun run db:seed          # Seed database with sample data
bun run db:studio        # Open database GUI (Prisma Studio)
bun run db:reset         # Reset database

# Code Quality
bun run lint             # Check for linting issues
bun run lint:fix         # Auto-fix linting issues
bun run format           # Format code with Prettier
bun run type-check       # TypeScript type checking

# Performance
bun run analyze          # Bundle size analysis
bun run perf:test        # Performance testing
```

### Development Workflow

**1. Feature Development:**

```bash
# Create feature branch
git checkout -b feature/actor-search-improvement

# Make changes with TypeScript strict mode
# All code must be fully typed - no 'any' types allowed

# Add comprehensive tests
bun run test:watch

# Run quality checks
bun run lint
bun run type-check
bun run test

# Commit changes
git add .
git commit -m "feat: improve actor search performance"
```

**2. Database Changes:**

```bash
# Create migration
bun run db:migrate --name add_actor_metadata

# Edit generated migration file in apps/api/src/database/migrations/

# Apply migration
bun run db:migrate

# Update TypeScript types
bun run db:generate

# Test changes
bun run test:integration
```

**3. API Development:**

```typescript
// Create new route
// File: apps/api/src/routes/actors/trending.ts
import { Elysia, t } from 'elysia';
import { ActorService } from '../services/actor-service';

export const trendingRoutes = (app: Elysia) =>
  app.get(
    '/trending',
    async ({ query }) => {
      const actorService = new ActorService(app.db);
      return await actorService.getTrendingActors(query);
    },
    {
      query: t.Object({
        limit: t.Optional(t.Numeric({ default: 20 })),
        timeframe: t.Optional(t.Enum(['day', 'week', 'month'])),
      }),
    },
  );
```

---

## Implementation Guide

### Phase 1: Foundation Setup

**Epic 1 Implementation Order:**

1. **Project Initialization**

   ```bash
   # Create monorepo structure
   bun create turbo@latest i-know
   cd i-know

   # Setup workspace configuration
   echo "packages:\n  - 'apps/*'\n  - 'packages/*'" > pnpm-workspace.yaml

   # Initialize applications
   bun create astro@latest apps/web --template blog --typescript strict --tailwind --yes
   bun create elysia apps/api --typescript
   bun init apps/scraper

   # Setup shared packages
   mkdir -p packages/{ui,types,database,utils}
   ```

2. **Database Setup**

   ```sql
   -- Create database
   CREATE DATABASE iknow_dev;

   -- Enable UUID extension
   CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

   -- Create core tables
   -- Run migration files in order
   ```

3. **Basic API Structure**

   ```typescript
   // apps/api/src/index.ts
   import { Elysia } from 'elysia';
   import { cors } from '@elysiajs/cors';
   import { actorRoutes } from './routes/actors';
   import { userRoutes } from './routes/users';

   const app = new Elysia()
     .use(cors())
     .use(actorRoutes)
     .use(userRoutes)
     .get('/health', () => ({ status: 'ok', timestamp: new Date().toISOString() }))
     .listen(3000);

   console.log('🚀 API server running at http://localhost:3000');
   ```

### Phase 2: Core Actor Identification

**Epic 2 Implementation Pattern:**

1. **Scraper Service Implementation**

   ```typescript
   // apps/scraper/src/services/imdb-service.ts
   export class IMDBService {
     async fetchActorViaAPI(imdbId: string): Promise<ActorData> {
       // Revolutionary GET method implementation
       // 100x faster than traditional scraping
     }

     async scrapeActorViaBrowser(imdbId: string): Promise<ActorData> {
       // Puppeteer fallback with rate limiting
     }

     async getCachedActor(imdbId: string): Promise<ActorData | null> {
       // Check database cache
     }
   }
   ```

2. **API Endpoint Implementation**

   ```typescript
   // apps/api/src/routes/actors/[id].ts
   export const actorRoutes = (app: Elysia) =>
     app.get('/actors/:id', async ({ params, set }) => {
       const actorService = new ActorService(app.db);

       try {
         const actor = await actorService.getActor(params.id);
         return { data: actor };
       } catch (error) {
         set.status = 404;
         return { error: error.message };
       }
     });
   ```

3. **Frontend Component Implementation**

   ```typescript
   // apps/web/src/components/features/actor-search/actor-card.tsx
   interface ActorCardProps {
     actor: Actor;
     onSelect?: (actor: Actor) => void;
   }

   export const ActorCard: React.FC<ActorCardProps> = ({ actor, onSelect }) => {
     return (
       <div className="actor-card" onClick={() => onSelect?.(actor)}>
         <img src={actor.photoUrl} alt={actor.name} />
         <div className="actor-info">
           <h3>{actor.name}</h3>
           <p>{actor.knownFor.join(', ')}</p>
         </div>
       </div>
     );
   };
   ```

### Phase 3: User Experience

**Component Development Standards:**

1. **Type Safety First**

   ```typescript
   // Always define interfaces
   interface UserPreferences {
     notifications: boolean;
     theme: 'light' | 'dark' | 'auto';
     language: string;
   }

   // Use generics properly
   interface ApiResponse<T> {
     data: T;
     error?: string;
   }

   // No 'any' types allowed
   const processData = (data: unknown): ProcessedData => {
     // Proper type guards and validation
   };
   ```

2. **Error Boundaries**

   ```typescript
   // apps/web/src/components/error-boundary.tsx
   export class ErrorBoundary extends React.Component<
     { children: React.ReactNode },
     { hasError: boolean; error?: Error }
   > {
     constructor(props: any) {
       super(props);
       this.state = { hasError: false };
     }

     static getDerivedStateFromError(error: Error) {
       return { hasError: true, error };
     }

     componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
       console.error('Error caught by boundary:', error, errorInfo);
     }

     render() {
       if (this.state.hasError) {
         return <ErrorFallback error={this.state.error} />;
       }

       return this.props.children;
     }
   }
   ```

3. **Performance Monitoring**

   ```typescript
   // apps/web/src/utils/performance.ts
   export const measureComponentRender = (componentName: string) => {
     return (WrappedComponent: React.ComponentType<any>) => {
       return (props: any) => {
         useEffect(() => {
           const startTime = performance.now();

           return () => {
             const endTime = performance.now();
             console.log(`${componentName} render time: ${endTime - startTime}ms`);
           };
         });

         return <WrappedComponent {...props} />;
       };
     };
   };
   ```

### Phase 4: Advanced Features

**Implementation Patterns for Complex Features:**

1. **Real-time Updates**

   ```typescript
   // apps/api/src/services/websocket-service.ts
   export class WebSocketService {
     private connections: Map<string, WebSocket> = new Map();

     subscribe(userId: string, ws: WebSocket) {
       this.connections.set(userId, ws);

       ws.onclose = () => {
         this.connections.delete(userId);
       };
     }

     broadcastToUser(userId: string, data: any) {
       const ws = this.connections.get(userId);
       if (ws?.readyState === WebSocket.OPEN) {
         ws.send(JSON.stringify(data));
       }
     }
   }
   ```

2. **Background Jobs**

   ```typescript
   // apps/scraper/src/scheduler/cron-jobs.ts
   export class JobScheduler {
     constructor(private imdbService: IMDBService) {}

     scheduleDailyUpdates() {
       cron.schedule('0 2 * * *', async () => {
         // 2 AM daily
         await this.updateTrendingActors();
         await this.refreshPopularContent();
       });
     }

     private async updateTrendingActors() {
       // Update trending actors data
     }
   }
   ```

3. **Analytics Integration**

   ```typescript
   // apps/api/src/services/analytics-service.ts
   export class AnalyticsService {
     async trackActorSearch(userId: string, query: string, results: number) {
       await this.analytics.track('actor_search', {
         userId,
         query,
         resultCount: results,
         timestamp: new Date().toISOString(),
       });
     }

     async trackContentView(userId: string, actorId: string, contentId: string) {
       await this.analytics.track('content_view', {
         userId,
         actorId,
         contentId,
         timestamp: new Date().toISOString(),
       });
     }
   }
   ```

---

## Testing Approach

### Testing Strategy Overview

**Testing Pyramid:**

1. **Unit Tests (70%)**: Fast, isolated component testing
2. **Integration Tests (20%)**: Service and API integration testing
3. **E2E Tests (10%)**: Critical user journey testing

### Unit Testing

**Component Testing Example:**

```typescript
// apps/web/src/components/features/actor-search/__tests__/actor-card.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { ActorCard } from '../actor-card';
import type { Actor } from '@iknow/types';

describe('ActorCard', () => {
  const mockActor: Actor = {
    id: 'test-actor-id',
    name: 'Tom Hanks',
    photoUrl: 'https://example.com/tom-hanks.jpg',
    knownFor: ['Forrest Gump', 'Saving Private Ryan'],
    createdAt: '2024-01-01T00:00:00Z',
    updatedAt: '2024-01-01T00:00:00Z'
  };

  it('renders actor information correctly', () => {
    render(<ActorCard actor={mockActor} />);

    expect(screen.getByText('Tom Hanks')).toBeInTheDocument();
    expect(screen.getByText('Forrest Gump, Saving Private Ryan')).toBeInTheDocument();
    expect(screen.getByRole('img')).toHaveAttribute('src', mockActor.photoUrl);
  });

  it('calls onSelect when clicked', () => {
    const mockOnSelect = vi.fn();
    render(<ActorCard actor={mockActor} onSelect={mockOnSelect} />);

    fireEvent.click(screen.getByRole('article'));
    expect(mockOnSelect).toHaveBeenCalledWith(mockActor);
  });

  it('handles missing photo gracefully', () => {
    const actorWithoutPhoto = { ...mockActor, photoUrl: undefined };
    render(<ActorCard actor={actorWithoutPhoto} />);

    const img = screen.getByRole('img');
    expect(img).toHaveAttribute('src', '/default-actor-avatar.png');
  });
});
```

**Service Testing Example:**

```typescript
// apps/api/src/services/__tests__/actor-service.test.ts
import { ActorService } from '../actor-service';
import { DatabaseService } from '@iknow/database';
import { vi } from 'vitest';

describe('ActorService', () => {
  let actorService: ActorService;
  let mockDb: DatabaseService;

  beforeEach(() => {
    mockDb = {
      queryOne: vi.fn(),
      query: vi.fn(),
    } as any;

    actorService = new ActorService(mockDb);
  });

  describe('getActor', () => {
    it('returns actor data when found', async () => {
      const mockActor = {
        id: 'test-id',
        name: 'Tom Hanks',
        bio: 'American actor',
      };

      mockDb.queryOne.mockResolvedValue(mockActor);

      const result = await actorService.getActor('test-id');

      expect(result).toEqual(mockActor);
      expect(mockDb.queryOne).toHaveBeenCalledWith(expect.stringContaining('WHERE a.id = $1'), [
        'test-id',
      ]);
    });

    it('throws ApiError when actor not found', async () => {
      mockDb.queryOne.mockResolvedValue(null);

      await expect(actorService.getActor('invalid-id')).rejects.toThrow('Actor not found');
    });
  });

  describe('searchActors', () => {
    it('returns search results with match scores', async () => {
      const mockResults = [
        {
          id: 'test-id',
          name: 'Tom Hanks',
          photo_url: 'https://example.com/tom.jpg',
          known_for: ['Forrest Gump'],
          match_score: '0.95',
        },
      ];

      mockDb.query.mockResolvedValue(mockResults);

      const result = await actorService.searchActors({
        q: 'tom hanks',
        limit: 20,
      });

      expect(result.data).toHaveLength(1);
      expect(result.data[0].matchScore).toBe(0.95);
      expect(result.meta.searchTime).toBeGreaterThan(0);
    });
  });
});
```

### Integration Testing

**API Integration Testing:**

```typescript
// tests/integration/actor-api.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { app } from '../../apps/api/src/index';

describe('Actor API Integration', () => {
  beforeAll(async () => {
    // Setup test database
    await setupTestDatabase();
  });

  afterAll(async () => {
    // Cleanup test database
    await cleanupTestDatabase();
  });

  it('GET /api/v1/actors/:id returns actor data', async () => {
    // Create test actor
    const testActor = await createTestActor();

    const response = await app
      .handle(new Request(`http://localhost:3000/api/v1/actors/${testActor.id}`))
      .then(res => res.json());

    expect(response.data).toMatchObject({
      id: testActor.id,
      name: testActor.name,
      bio: testActor.bio,
    });
  });

  it('GET /api/v1/actors/search returns relevant results', async () => {
    // Create test data
    await createTestActors([
      { name: 'Tom Hanks', knownFor: ['Forrest Gump'] },
      { name: 'Tom Cruise', knownFor: ['Top Gun'] },
    ]);

    const response = await app
      .handle(new Request('http://localhost:3000/api/v1/actors/search?q=tom'))
      .then(res => res.json());

    expect(response.data).toHaveLength(2);
    expect(response.data[0].name).toMatch(/Tom/);
    expect(response.meta.searchTime).toBeGreaterThan(0);
  });
});
```

### E2E Testing

**Critical User Journey Testing:**

```typescript
// tests/e2e/actor-identification.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Actor Identification Journey', () => {
  test('user can search for and identify actor', async ({ page }) => {
    await page.goto('/');

    // Search for actor
    await page.fill('[data-testid="search-input"]', 'tom hanks');
    await page.click('[data-testid="search-button"]');

    // Wait for search results
    await page.waitForSelector('[data-testid="actor-search-results"]');

    // Verify search results
    const actorCards = page.locator('[data-testid="actor-card"]');
    await expect(actorCards).toHaveCount.greaterThan(0);

    // Click on first actor
    await actorCards.first().click();

    // Verify actor profile page
    await page.waitForSelector('[data-testid="actor-profile"]');
    await expect(page.locator('h1')).toContainText('Tom Hanks');

    // Verify filmography
    const filmography = page.locator('[data-testid="actor-filmography"]');
    await expect(filmography).toBeVisible();
    await expect(filmography.locator('[data-testid="filmography-item"]')).toHaveCount.greaterThan(
      0,
    );
  });

  test('user can add content to watchlist', async ({ page }) => {
    // Login user
    await page.goto('/login');
    await page.fill('[data-testid="email-input"]', 'test@example.com');
    await page.fill('[data-testid="password-input"]', 'password123');
    await page.click('[data-testid="login-button"]');

    // Navigate to actor profile
    await page.goto('/actor/tom-hanks');

    // Find content in filmography
    const firstContent = page.locator('[data-testid="filmography-item"]').first();
    await expect(firstContent).toBeVisible();

    // Add to watchlist
    await firstContent.locator('[data-testid="add-to-watchlist"]').click();

    // Verify watchlist updated
    await page.goto('/profile/watchlist');
    const watchlistItems = page.locator('[data-testid="watchlist-item"]');
    await expect(watchlistItems).toHaveCount.greaterThan(0);
  });
});
```

### Performance Testing

**Load Testing Configuration:**

```typescript
// tests/performance/actor-search-load.test.ts
import { check, sleep } from 'k6';
import http from 'k6/http';

export let options = {
  stages: [
    { duration: '2m', target: 100 }, // Ramp up to 100 users
    { duration: '5m', target: 100 }, // Stay at 100 users
    { duration: '2m', target: 200 }, // Ramp up to 200 users
    { duration: '5m', target: 200 }, // Stay at 200 users
    { duration: '2m', target: 0 }, // Ramp down
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'], // 95% of requests under 500ms
    http_req_failed: ['rate<0.1'], // Less than 10% failed requests
  },
};

export default function () {
  const searchQueries = ['tom hanks', 'leonardo dicaprio', 'scarlett johansson'];
  const query = searchQueries[Math.floor(Math.random() * searchQueries.length)];

  const response = http.get(`http://localhost:3000/api/v1/actors/search?q=${query}&limit=20`);

  check(response, {
    'status is 200': r => r.status === 200,
    'response time < 500ms': r => r.timings.duration < 500,
    'has search results': r => JSON.parse(r.body).data.length > 0,
  });

  sleep(1);
}
```

### Testing Standards

**Coverage Requirements:**

- **Unit Tests**: 90%+ coverage for business logic
- **Integration Tests**: 80%+ coverage for API endpoints
- **E2E Tests**: 100% coverage for critical user journeys

**Quality Gates:**

```bash
# Run all quality checks
bun run test:coverage
bun run lint
bun run type-check
bun run perf:test

# All must pass before merge
```

**Test Organization:**

```
tests/
├── unit/                    # Fast unit tests
│   ├── components/
│   ├── services/
│   └── utils/
├── integration/             # API and service integration
│   ├── api/
│   └── database/
├── e2e/                     # End-to-end user journeys
│   ├── auth.spec.ts
│   ├── search.spec.ts
│   └── profile.spec.ts
└── performance/             # Load and performance testing
    ├── search-load.test.ts
    └── api-stress.test.ts
```

---

## Deployment Strategy

### Container Configuration

**Dockerfile for Backend API:**

```dockerfile
# apps/api/Dockerfile
FROM oven/bun:1.3.1-alpine AS base
WORKDIR /app

# Install dependencies
COPY package.json bun.lockb ./
RUN bun install --frozen-lockfile --production

# Copy source code
COPY . .

# Build application
RUN bun run build

# Production stage
FROM base AS production
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/api/v1/health || exit 1

# Start application
CMD ["bun", "src/index.ts"]
```

**Dockerfile for Frontend:**

```dockerfile
# apps/web/Dockerfile
FROM node:20-alpine AS base
WORKDIR /app

# Install dependencies
COPY package.json bun.lockb ./
RUN bun install --frozen-lockfile

# Copy source and build
COPY . .
RUN bun run build

# Production stage with nginx
FROM nginx:alpine AS production
COPY --from=base /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

**Docker Compose for Development:**

```yaml
# docker-compose.yml
version: '3.8'

services:
  web:
    build:
      context: ./apps/web
      dockerfile: Dockerfile
    ports:
      - '4321:80'
    environment:
      - API_URL=http://api:3000
    depends_on:
      - api

  api:
    build:
      context: ./apps/api
      dockerfile: Dockerfile
    ports:
      - '3000:3000'
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/iknow
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis

  scraper:
    build:
      context: ./apps/scraper
      dockerfile: Dockerfile
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/iknow
    depends_on:
      - db

  db:
    image: postgres:18-alpine
    environment:
      - POSTGRES_DB=iknow
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - '5432:5432'

  redis:
    image: redis:7-alpine
    ports:
      - '6379:6379'
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

### CI/CD Pipeline

**GitHub Actions Configuration:**

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  NODE_VERSION: '20'
  BUN_VERSION: '1.3.1'

jobs:
  test:
    name: Test and Quality Checks
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:18
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: iknow_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: ${{ env.BUN_VERSION }}

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Setup environment
        run: |
          cp .env.example .env.local
          echo "DATABASE_URL=postgresql://postgres:postgres@localhost:5432/iknow_test" >> .env.local
          echo "REDIS_URL=redis://localhost:6379" >> .env.local

      - name: Run database migrations
        run: bun run db:migrate

      - name: Run linting
        run: bun run lint

      - name: Run type checking
        run: bun run type-check

      - name: Run unit tests
        run: bun run test:unit

      - name: Run integration tests
        run: bun run test:integration

      - name: Run E2E tests
        run: bun run test:e2e

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info

  build:
    name: Build Applications
    runs-on: ubuntu-latest
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: ${{ env.BUN_VERSION }}

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Build applications
        run: bun run build

      - name: Build Docker images
        run: |
          docker build -t iknow-api ./apps/api
          docker build -t iknow-web ./apps/web
          docker build -t iknow-scraper ./apps/scraper

      - name: Push images to registry
        if: github.ref == 'refs/heads/main'
        run: |
          echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
          docker push iknow-api:latest
          docker push iknow-web:latest
          docker push iknow-scraper:latest

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
      - name: Deploy to Railway
        run: |
          curl -X POST https://api.railway.app/v1/projects/${{ secrets.RAILWAY_PROJECT_ID }}/deploy \
            -H "Authorization: Bearer ${{ secrets.RAILWAY_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{"serviceId": "${{ secrets.RAILWAY_SERVICE_ID }}"}'

      - name: Run smoke tests
        run: |
          sleep 30 # Wait for deployment
          curl -f https://iknow.app/api/v1/health || exit 1

      - name: Notify deployment success
        run: |
          curl -X POST https://api.slack.com/webhooks/... \
            -H 'Content-type: application/json' \
            --data '{"text":"✅ I Know deployed successfully to production"}'
```

### Environment Management

**Production Environment Variables:**

```bash
# Database
DATABASE_URL="${{ secrets.DATABASE_URL }}"
REDIS_URL="${{ secrets.REDIS_URL }}"

# Authentication
JWT_SECRET="${{ secrets.JWT_SECRET }}"
JWT_REFRESH_SECRET="${{ secrets.JWT_REFRESH_SECRET }}"

# External Services
IMDB_API_KEY="${{ secrets.IMDB_API_KEY }}"
CDN_URL="${{ secrets.CDN_URL }}"

# Monitoring
DATADOG_API_KEY="${{ secrets.DATADOG_API_KEY }}"
SENTRY_DSN="${{ secrets.SENTRY_DSN }}"

# Features
ENABLE_SCRAPING="true"
ENABLE_ANALYTICS="true"
ENABLE_CACHE="true"

# Performance
NODE_ENV="production"
LOG_LEVEL="info"
RATE_LIMIT_REQUESTS="1000"
RATE_LIMIT_WINDOW="900000"
```

### Monitoring and Observability

**Health Check Endpoints:**

```typescript
// apps/api/src/routes/health.ts
export const healthRoutes = (app: Elysia) =>
  app.get('/health', async () => {
    const checks = await Promise.allSettled([
      checkDatabase(),
      checkRedis(),
      checkExternalAPIs(),
      checkDiskSpace(),
    ]);

    const status = checks.every(c => c.status === 'fulfilled') ? 'healthy' : 'degraded';
    const response: HealthResponse = {
      status,
      timestamp: new Date().toISOString(),
      checks: checks.map((check, index) => ({
        name: ['database', 'redis', 'external_apis', 'disk_space'][index],
        status: check.status,
        ...(check.status === 'rejected' && {
          error: check.reason.message,
          responseTime: check.reason.responseTime,
        }),
      })),
    };

    return response;
  });
```

**Application Monitoring:**

```typescript
// apps/api/src/middleware/monitoring-middleware.ts
import { StatsD } from 'hot-shots';

const statsd = new StatsD({
  host: process.env.STATSD_HOST,
  port: 8125,
});

export const monitoringMiddleware = (app: Elysia) =>
  app
    .onRequest(({ request }) => {
      request.startTime = Date.now();
    })
    .onResponse(({ request, set }) => {
      const duration = Date.now() - (request.startTime || 0);
      const route = new URL(request.url).pathname;

      // Record metrics
      statsd.histogram('api.request.duration', duration, [`route:${route}`]);
      statsd.increment('api.request.count', [`route:${route}`, `status:${set.status}`]);

      // Alert on slow requests
      if (duration > 500) {
        statsd.increment('api.request.slow', [`route:${route}`]);
      }
    });
```

### Deployment Checklist

**Pre-deployment Requirements:**

- [ ] All tests passing (unit, integration, E2E)
- [ ] Code coverage above 90%
- [ ] No TypeScript errors
- [ ] No ESLint warnings
- [ ] Performance tests meeting targets
- [ ] Security scan passed
- [ ] Database migrations tested
- [ ] Environment variables configured
- [ ] Health checks passing
- [ ] Backup strategy confirmed

**Post-deployment Verification:**

- [ ] Application responding to health checks
- [ ] Database connectivity verified
- [ ] Cache service operational
- [ ] External API integrations working
- [ ] Monitoring dashboards showing data
- [ ] Smoke tests passing
- [ ] Performance metrics within targets
- [ ] Error rates below thresholds
- [ ] User authentication working
- [ ] Core functionality verified

---

_This technical specification provides comprehensive implementation guidance for the I Know entertainment intelligence platform, covering all aspects from development setup through deployment strategy. The document serves as the definitive technical reference for the development team throughout the implementation lifecycle._

_Generated: 2025-10-29_
_Author: Eduardo Menoncello_
